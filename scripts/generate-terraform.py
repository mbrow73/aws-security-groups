#!/usr/bin/env python3
"""
AWS Security Group Platform - Terraform Generator

Converts security-groups.yaml to Terraform configuration using the security-group module
and vpc-discovery module.

Usage:
    python generate-terraform.py <account_directory_path>

The script generates:
- main.tf: Using security-group and vpc-discovery modules
- backend.tf: S3 backend configuration with per-account state key
- providers.tf: AWS provider configuration
"""

import sys
import os
import yaml
import argparse
from typing import Dict, List, Any, Optional
from pathlib import Path
import re
import json


class TerraformGenerator:
    """Generates Terraform configuration from security groups YAML"""
    
    def __init__(self, account_dir: str):
        self.account_dir = Path(account_dir)
        self.repo_root = self._find_repo_root()
        self.account_id = self._extract_account_id()
        
        # Load configuration files
        self.config = self._load_security_groups_config()
        self.guardrails = self._load_guardrails()
        self.prefix_lists = self._load_prefix_lists()
        
        # Terraform configuration
        self.terraform_dir = self.account_dir / "terraform"
        self.terraform_dir.mkdir(exist_ok=True)
    
    def _find_repo_root(self) -> Path:
        """Find the repository root by looking for guardrails.yaml"""
        current = self.account_dir
        while current != current.parent:
            if (current / "guardrails.yaml").exists():
                return current
            current = current.parent
        raise FileNotFoundError("Could not find repository root with guardrails.yaml")
    
    def _extract_account_id(self) -> str:
        """Extract account ID from directory name or config"""
        # Try directory name first
        account_dir_name = self.account_dir.name
        if re.match(r'^\d{12}$', account_dir_name):
            return account_dir_name
        
        # Try config file
        sg_file = self.account_dir / "security-groups.yaml"
        if sg_file.exists():
            try:
                with open(sg_file, 'r') as f:
                    data = yaml.safe_load(f)
                    if data and 'account_id' in data:
                        return str(data['account_id'])
            except:
                pass
        
        raise ValueError(f"Could not determine account ID from directory '{account_dir_name}'")
    
    def _load_security_groups_config(self) -> Dict[str, Any]:
        """Load security groups configuration"""
        sg_file = self.account_dir / "security-groups.yaml"
        if not sg_file.exists():
            raise FileNotFoundError(f"security-groups.yaml not found in {self.account_dir}")
        
        try:
            with open(sg_file, 'r') as f:
                config = yaml.safe_load(f)
                if not config:
                    raise ValueError("security-groups.yaml is empty")
                return config
        except yaml.YAMLError as e:
            raise ValueError(f"Invalid YAML in security-groups.yaml: {e}")
    
    def _load_guardrails(self) -> Dict[str, Any]:
        """Load guardrails configuration"""
        try:
            with open(self.repo_root / "guardrails.yaml", 'r') as f:
                return yaml.safe_load(f) or {}
        except:
            return {}
    
    def _load_prefix_lists(self) -> Dict[str, Any]:
        """Load prefix lists configuration"""
        try:
            with open(self.repo_root / "prefix-lists.yaml", 'r') as f:
                return yaml.safe_load(f) or {}
        except:
            return {}
    
    def generate_all(self):
        """Generate all Terraform files"""
        print(f"üîß Generating Terraform configuration for account {self.account_id}")
        print(f"üìÅ Output directory: {self.terraform_dir}")
        
        # Generate each file
        self.generate_main_tf()
        self.generate_backend_tf()
        self.generate_providers_tf()
        self.generate_variables_tf()
        
        print("‚úÖ Terraform configuration generated successfully!")
    
    def generate_main_tf(self):
        """Generate main.tf with module calls"""
        content = self._generate_main_tf_content()
        output_file = self.terraform_dir / "main.tf"
        
        with open(output_file, 'w') as f:
            f.write(content)
        
        print(f"   üìÑ Generated {output_file}")
    
    def _generate_main_tf_content(self) -> str:
        """Generate the content for main.tf"""
        content = []
        
        # Header comment
        content.append(f"""# AWS Security Group Platform - Account {self.account_id}
# Generated from security-groups.yaml
# Do not edit this file directly - edit the YAML file and regenerate

terraform {{
  required_version = ">= 1.6"
  required_providers {{
    aws = {{
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }}
  }}
}}
""")
        
        # VPC Discovery Module
        content.append(self._generate_vpc_discovery_module())
        
        # Security Group Modules
        security_groups = self.config.get('security_groups', {})
        for sg_name, sg_config in security_groups.items():
            content.append(self._generate_security_group_module(sg_name, sg_config))
        
        return "\n".join(content)
    
    def _generate_vpc_discovery_module(self) -> str:
        """Generate VPC discovery module call"""
        vpc_config = self.config.get('vpc', {})
        vpc_id = vpc_config.get('vpc_id', 'auto')
        
        # Build module call
        module_content = [
            "# VPC Discovery Module",
            "module \"vpc_discovery\" {",
            f"  source = \"../../modules/vpc-discovery\"",
            "",
            f"  account_id = \"{self.account_id}\"",
            f"  vpc_id     = \"{vpc_id}\"",
        ]
        
        # Add optional parameters
        if 'filter_tags' in vpc_config:
            filter_tags = vpc_config['filter_tags']
            tags_hcl = self._dict_to_hcl(filter_tags, indent=2)
            module_content.extend([
                f"  vpc_filter_tags = {tags_hcl}"
            ])
        
        if vpc_config.get('require_internet_access'):
            module_content.append("  require_internet_access = true")
        
        if vpc_config.get('require_private_subnets'):
            module_content.append("  require_private_subnets = true")
        
        if vpc_config.get('require_public_subnets'):
            module_content.append("  require_public_subnets = true")
        
        min_azs = vpc_config.get('min_availability_zones')
        if min_azs and min_azs > 1:
            module_content.append(f"  min_availability_zones = {min_azs}")
        
        module_content.append("}")
        
        return "\n".join(module_content)
    
    def _generate_security_group_module(self, sg_name: str, sg_config: Dict[str, Any]) -> str:
        """Generate security group module call"""
        module_content = [
            f"# Security Group: {sg_name}",
            f"module \"sg_{self._sanitize_terraform_name(sg_name)}\" {{",
            f"  source = \"../../modules/security-group\"",
            "",
            f"  name        = \"{sg_name}\"",
            f"  description = \"{sg_config.get('description', '')}\"",
            f"  vpc_id      = module.vpc_discovery.vpc_id",
        ]
        
        # Add tags
        tags = sg_config.get('tags', {})
        # Add mandatory tags
        tags['ManagedBy'] = 'sg-platform'
        tags['AccountId'] = self.account_id
        if 'team' not in [k.lower() for k in tags.keys()]:
            tags['Team'] = 'unknown'
        
        if tags:
            tags_hcl = self._dict_to_hcl(tags, indent=2)
            module_content.append(f"  tags = {tags_hcl}")
        
        # Add ingress rules
        if 'ingress' in sg_config and sg_config['ingress']:
            ingress_rules = self._convert_rules_to_terraform(sg_config['ingress'])
            module_content.append(f"  ingress_rules = {ingress_rules}")
        
        # Add egress rules
        if 'egress' in sg_config and sg_config['egress']:
            egress_rules = self._convert_rules_to_terraform(sg_config['egress'])
            module_content.append(f"  egress_rules = {egress_rules}")
        else:
            # Add default egress rule if none specified
            default_egress = """[
    {
      protocol    = "-1"
      from_port   = 0
      to_port     = 0
      cidr_blocks = ["0.0.0.0/0"]
      description = "Default egress rule"
    }
  ]"""
            module_content.append(f"  egress_rules = {default_egress}")
        
        # Add VPC ID reference if explicitly set
        explicit_vpc_id = sg_config.get('vpc_id')
        if explicit_vpc_id and explicit_vpc_id != 'auto':
            module_content.append(f"  # Explicit VPC ID override: {explicit_vpc_id}")
            module_content[-3] = f"  vpc_id      = \"{explicit_vpc_id}\""  # Replace the vpc_discovery reference
        
        module_content.append("}")
        
        return "\n".join(module_content)
    
    def _convert_rules_to_terraform(self, rules: List[Dict[str, Any]]) -> str:
        """Convert YAML rules to Terraform HCL format"""
        if not rules:
            return "[]"
        
        terraform_rules = []
        
        for rule in rules:
            tf_rule = {
                'protocol': rule.get('protocol', 'tcp'),
                'from_port': rule.get('from_port', 0),
                'to_port': rule.get('to_port', 0),
                'description': rule.get('description', '')
            }
            
            # Add CIDR blocks
            if 'cidr_blocks' in rule:
                tf_rule['cidr_blocks'] = rule['cidr_blocks']
            
            if 'ipv6_cidr_blocks' in rule:
                tf_rule['ipv6_cidr_blocks'] = rule['ipv6_cidr_blocks']
            
            # Add security group references
            if 'security_groups' in rule:
                tf_rule['source_security_group_ids'] = rule['security_groups']
            
            # Add self reference
            if rule.get('self', False):
                tf_rule['self'] = True
            
            # Add prefix list references
            if 'prefix_list_ids' in rule:
                # Convert named prefix lists to Terraform references
                prefix_list_refs = []
                for prefix_list_id in rule['prefix_list_ids']:
                    if prefix_list_id.startswith('pl-'):
                        # AWS managed prefix list
                        prefix_list_refs.append(prefix_list_id)
                    else:
                        # Reference to our managed prefix list
                        # This would need to be created by the baseline terraform
                        prefix_list_refs.append(f"data.aws_ec2_managed_prefix_list.{prefix_list_id}.id")
                
                tf_rule['prefix_list_ids'] = prefix_list_refs
            
            terraform_rules.append(tf_rule)
        
        # Convert to HCL format
        return self._rules_list_to_hcl(terraform_rules)
    
    def _rules_list_to_hcl(self, rules: List[Dict[str, Any]]) -> str:
        """Convert rules list to HCL format"""
        if not rules:
            return "[]"
        
        hcl_lines = ["["]
        
        for i, rule in enumerate(rules):
            hcl_lines.append("    {")
            
            # Basic fields
            hcl_lines.append(f"      protocol    = \"{rule['protocol']}\"")
            hcl_lines.append(f"      from_port   = {rule['from_port']}")
            hcl_lines.append(f"      to_port     = {rule['to_port']}")
            hcl_lines.append(f"      description = \"{rule['description']}\"")
            
            # CIDR blocks
            if 'cidr_blocks' in rule:
                cidr_list = json.dumps(rule['cidr_blocks'])
                hcl_lines.append(f"      cidr_blocks = {cidr_list}")
            
            if 'ipv6_cidr_blocks' in rule:
                cidr_list = json.dumps(rule['ipv6_cidr_blocks'])
                hcl_lines.append(f"      ipv6_cidr_blocks = {cidr_list}")
            
            # Security group references
            if 'source_security_group_ids' in rule:
                sg_list = json.dumps(rule['source_security_group_ids'])
                hcl_lines.append(f"      source_security_group_ids = {sg_list}")
            
            # Self reference
            if rule.get('self'):
                hcl_lines.append(f"      self = true")
            
            # Prefix list references
            if 'prefix_list_ids' in rule:
                prefix_list = json.dumps(rule['prefix_list_ids'])
                hcl_lines.append(f"      prefix_list_ids = {prefix_list}")
            
            # Close rule block
            if i < len(rules) - 1:
                hcl_lines.append("    },")
            else:
                hcl_lines.append("    }")
        
        hcl_lines.append("  ]")
        
        return "\n".join(hcl_lines)
    
    def _dict_to_hcl(self, data: Dict[str, Any], indent: int = 0) -> str:
        """Convert dictionary to HCL format"""
        if not data:
            return "{}"
        
        lines = ["{"]
        indent_str = "  " * (indent + 1)
        
        for key, value in data.items():
            if isinstance(value, str):
                lines.append(f'{indent_str}{key} = "{value}"')
            elif isinstance(value, bool):
                lines.append(f'{indent_str}{key} = {str(value).lower()}')
            elif isinstance(value, (int, float)):
                lines.append(f'{indent_str}{key} = {value}')
            else:
                # For complex types, use JSON encoding
                lines.append(f'{indent_str}{key} = {json.dumps(value)}')
        
        lines.append("  " * indent + "}")
        return "\n".join(lines)
    
    def _sanitize_terraform_name(self, name: str) -> str:
        """Sanitize name for use as Terraform resource identifier"""
        # Replace non-alphanumeric characters with underscores
        sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', name)
        # Ensure it starts with a letter or underscore
        if sanitized and sanitized[0].isdigit():
            sanitized = f'sg_{sanitized}'
        return sanitized or 'unnamed'
    
    def generate_backend_tf(self):
        """Generate backend.tf with S3 backend configuration"""
        content = f"""# AWS Security Group Platform - Terraform Backend Configuration
# Account: {self.account_id}

terraform {{
  backend "s3" {{
    bucket         = "aws-sg-platform-terraform-state"
    key            = "accounts/{self.account_id}/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "aws-sg-platform-terraform-locks"
    
    # Optional: Uncomment if using role assumption
    # role_arn = "arn:aws:iam::{self.account_id}:role/TerraformExecutionRole"
  }}
}}
"""
        
        output_file = self.terraform_dir / "backend.tf"
        with open(output_file, 'w') as f:
            f.write(content)
        
        print(f"   üìÑ Generated {output_file}")
    
    def generate_providers_tf(self):
        """Generate providers.tf with AWS provider configuration"""
        content = f"""# AWS Security Group Platform - Provider Configuration
# Account: {self.account_id}

terraform {{
  required_version = ">= 1.6"
  
  required_providers {{
    aws = {{
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }}
  }}
}}

provider "aws" {{
  region = var.aws_region
  
  # Optional: Uncomment for cross-account deployments
  # assume_role {{
  #   role_arn = "arn:aws:iam::{self.account_id}:role/TerraformExecutionRole"
  # }}
  
  default_tags {{
    tags = {{
      ManagedBy   = "sg-platform"
      AccountId   = "{self.account_id}"
      Environment = var.environment
      Repository  = "aws-security-groups"
    }}
  }}
}}

# Data sources for context
data "aws_caller_identity" "current" {{}}
data "aws_region" "current" {{}}

# Validate that we're in the correct account
locals {{
  expected_account_id = "{self.account_id}"
  actual_account_id   = data.aws_caller_identity.current.account_id
  
  account_validation = local.expected_account_id == local.actual_account_id ? true : tobool("Account ID mismatch: expected ${{local.expected_account_id}}, got ${{local.actual_account_id}}")
}}
"""
        
        output_file = self.terraform_dir / "providers.tf"
        with open(output_file, 'w') as f:
            f.write(content)
        
        print(f"   üìÑ Generated {output_file}")
    
    def generate_variables_tf(self):
        """Generate variables.tf with input variables"""
        # Determine environment from config or directory structure
        environment = self.config.get('environment', self._guess_environment())
        
        content = f"""# AWS Security Group Platform - Variables
# Account: {self.account_id}

variable "aws_region" {{
  description = "AWS region for deployment"
  type        = string
  default     = "us-east-1"
}}

variable "environment" {{
  description = "Environment name (dev, staging, prod)"
  type        = string
  default     = "{environment}"
  
  validation {{
    condition     = contains(["dev", "development", "staging", "prod", "production"], var.environment)
    error_message = "Environment must be one of: dev, development, staging, prod, production."
  }}
}}

variable "additional_tags" {{
  description = "Additional tags to apply to all resources"
  type        = map(string)
  default     = {{}}
}}

# Account-specific variables
locals {{
  account_id = "{self.account_id}"
  
  # Common tags for all resources
  common_tags = merge({{
    ManagedBy   = "sg-platform"
    AccountId   = local.account_id
    Environment = var.environment
    Repository  = "aws-security-groups"
    Terraform   = "true"
  }}, var.additional_tags)
}}

# Outputs for debugging and reference
output "account_validation" {{
  description = "Account ID validation"
  value = {{
    expected_account = local.account_id
    actual_account   = data.aws_caller_identity.current.account_id
    region          = data.aws_region.current.name
    is_valid        = local.expected_account_id == local.actual_account_id
  }}
}}

output "vpc_discovery_results" {{
  description = "Results from VPC discovery module"
  value = {{
    vpc_id              = module.vpc_discovery.vpc_id
    vpc_cidr           = module.vpc_discovery.vpc_cidr
    availability_zones = module.vpc_discovery.availability_zones
    has_internet_access = module.vpc_discovery.has_internet_access
    has_private_subnets = module.vpc_discovery.has_private_subnets
    has_public_subnets  = module.vpc_discovery.has_public_subnets
  }}
}}

output "security_groups" {{
  description = "Created security groups"
  value = {{"""
        
        # Add security group outputs
        security_groups = self.config.get('security_groups', {})
        for sg_name in security_groups.keys():
            sanitized_name = self._sanitize_terraform_name(sg_name)
            content += f"""
    {sg_name} = {{
      id   = module.sg_{sanitized_name}.security_group_id
      arn  = module.sg_{sanitized_name}.security_group_arn
      name = module.sg_{sanitized_name}.security_group_name
    }}"""
        
        content += """
  }
}
"""
        
        output_file = self.terraform_dir / "variables.tf"
        with open(output_file, 'w') as f:
            f.write(content)
        
        print(f"   üìÑ Generated {output_file}")
    
    def _guess_environment(self) -> str:
        """Guess environment from directory structure or account ID patterns"""
        account_path_parts = str(self.account_dir).lower().split('/')
        
        # Look for environment indicators in path
        for part in account_path_parts:
            if 'prod' in part or 'production' in part:
                return 'production'
            elif 'staging' in part or 'stage' in part:
                return 'staging'
            elif 'dev' in part or 'development' in part:
                return 'development'
        
        # Check if account ID matches known patterns
        # This would be customized based on your account naming conventions
        if self.account_id.endswith('001'):  # Production accounts end in 001
            return 'production'
        elif self.account_id.endswith('002'):  # Staging accounts end in 002
            return 'staging'
        elif self.account_id.endswith('003'):  # Dev accounts end in 003
            return 'development'
        
        return 'unknown'


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='Generate Terraform configuration from security-groups.yaml',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python generate-terraform.py accounts/123456789012
  python generate-terraform.py accounts/production
        """
    )
    
    parser.add_argument(
        'account_dir',
        help='Path to the account directory containing security-groups.yaml'
    )
    
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Show what would be generated without writing files'
    )
    
    parser.add_argument(
        '--force',
        action='store_true',
        help='Overwrite existing Terraform files'
    )
    
    args = parser.parse_args()
    
    try:
        generator = TerraformGenerator(args.account_dir)
        
        if args.dry_run:
            print(f"üîç Dry run mode - showing what would be generated for account {generator.account_id}")
            print(f"üìÅ Target directory: {generator.terraform_dir}")
            print("üìÑ Files that would be generated:")
            print("   - main.tf")
            print("   - backend.tf")
            print("   - providers.tf")
            print("   - variables.tf")
            return
        
        # Check if files already exist
        terraform_files = ['main.tf', 'backend.tf', 'providers.tf', 'variables.tf']
        existing_files = [f for f in terraform_files if (generator.terraform_dir / f).exists()]
        
        if existing_files and not args.force:
            print(f"‚ö†Ô∏è  The following Terraform files already exist in {generator.terraform_dir}:")
            for f in existing_files:
                print(f"   - {f}")
            print("\nUse --force to overwrite existing files, or remove them manually.")
            sys.exit(1)
        
        generator.generate_all()
        
    except Exception as e:
        print(f"‚ùå Generation error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()